#面试题
##·final, finally, finalize三者的区别:

	·final
		表示不可变的，用来修饰类、方法和变量。
	 	
	 	当它修饰类的时候表示该类是不可被继承的，因为抽象类就是被继承的，所以abstract关键字和final关键字不能共存。
	 	
	 	当它修饰方法的时候表示该方法是不能被重写的。
	 	
	 	当它修饰变量的时候表示该变量的值不能发生变化，对于用final修饰的变量我们必须在申明它的时候赋值或者在构造函数中给它赋值。
	·finally
	 	是异常处理中的一个关键字，通常用于try-catch-finally结构。

	 	它一般用于资源释放，例如关闭数据库的连接、输入输出流的关闭，在finally结构中的代码不管有没有异常发生都会执行。

	 	但是finally中的代码不是总会被执行的，在以下情况中不会执行finally中的代码：
	 		·1.在进入try模块之前程序发生了异常
	 		·2.在try模块中调用了System.exit(0)终止了JVM的运行。
	 		·3.在try模块或catch模块中程序被中断，比如死机。

	 	finally运行顺序:
	 		·1.finally在try模块和catch模块内的return执行后，返回前执行。
	 		·2.如果finally中没有return，则其执行结果不会影响try模块和catch模块中已确定的返回值。
	 		·3.如果finally中有return，则执行结果会直接返回。
	·finalize
		是Object类的一个方法，因为所有的类都继承自Object类，所以所有的类都有finalize方法。

		在垃圾收集器将该对象清除出内存之前都会先调用它的finalize方法，做一些内存清理工作，通常这部分内存是非Java内存，如Socket，finalize只会被调用一次。

##synchronized与lock的异同？

	·相同点: 二者都可以解决线程的安全问题
	·不同点: synchronized机制在执行完相应的同步代码后，自动的释放同步监视器
		Lock需要手动的启动同步(lock()), 同时结束同步也需要手动实现(unlock())

##如何解决线程安全问题？有哪几种方式

	·1.同步代码块
	·2.同步方法
	·3.Lock锁

##sleep()和wait()方法的异同

	·相同点: 一旦执行，都可以使得当前的线程进入阻塞状态
	·不同点: 
		·1.两个方法声明的位置不同
		·2.两个方法的调用要求不同: sleep()可以在任何需要的场景调用，wait()必须在同步代码块或同步方法中调用
		·3.关于是否释放同步监视器: 如果两个方法都使用在同步代码块或同步方法中时，sleep()不会释放同步监视器，wait()会释放同步监视器

##如何理解Callable接口创建线程比Runnable接口强大？

	·1.call()方法可以有返回值的
	·2.call()可以抛出异常，被外面的操作捕获，获取异常的信息
	·3.Callable是支持泛型的

##创建多线程有几种方式？

	·四种:
		·方式1: 继承于Thread类
		·方式2: 实现Runnable接口
		·方式3: 实现Callable接口 ————JDK 5.0新增
		·方式4: 使用线程池